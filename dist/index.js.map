{
  "version": 3,
  "sources": ["../lib/resolve_stride.js", "../lib/main.js", "../lib/numel.js", "../lib/assign.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Resolves a stride length for broadcasting a one-dimensional array.\n*\n* @private\n* @param {NonNegativeInteger} M - input array length\n* @param {NonNegativeInteger} N - output array length\n* @throws {Error} input arrays must be broadcast compatible\n* @returns {NonNegativeInteger} stride length\n*/\nfunction resolveStride( M, N ) {\n\t// Note that this effectively in-lines logic from `@stdlib/array/base/broadcast-array` in order to avoid unnecessary object creation...\n\tif ( M === 1 ) {\n\t\treturn 0;\n\t}\n\tif ( M === N ) {\n\t\treturn 1;\n\t}\n\tthrow new Error( 'invalid arguments. Input arguments are not broadcast compatible.' );\n}\n\n\n// EXPORTS //\n\nmodule.exports = resolveStride;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar resolveGetter = require( '@stdlib/array-base-resolve-getter' );\nvar maxn = require( '@stdlib/math-base-special-maxn' );\nvar resolveStride = require( './resolve_stride.js' );\n\n\n// MAIN //\n\n/**\n* Takes elements from either one of two arrays depending on a condition.\n*\n* @param {Collection} condition - indicator array\n* @param {Collection} x - first input array\n* @param {Collection} y - second input array\n* @throws {Error} input arrays must be broadcast compatible\n* @returns {Array} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var y = [ 5, 6, 7, 8 ];\n*\n* var condition = [ true, false, true, false ];\n*\n* var z = where( condition, x, y );\n* // returns [ 1, 6, 3, 8 ]\n*/\nfunction where( condition, x, y ) {\n\tvar xget;\n\tvar yget;\n\tvar cget;\n\tvar lens;\n\tvar out;\n\tvar sx;\n\tvar sy;\n\tvar sc;\n\tvar ix;\n\tvar iy;\n\tvar ic;\n\tvar N;\n\tvar v;\n\tvar i;\n\n\t// Cache the lengths of the input arrays:\n\tlens = [ condition.length, x.length, y.length ];\n\n\t// Check whether we can avoid doing any further work...\n\tif ( lens[ 0 ] === 0 ) {\n\t\t// E.g., `where( [], [ 1, 2 ], [ 3, 4 ] )`\n\t\treturn [];\n\t}\n\t// Compute the output array length:\n\tN = maxn( lens[ 0 ], lens[ 1 ], lens[ 2 ] );\n\n\t// Broadcast the arrays by computing strides:\n\tsc = resolveStride( lens[ 0 ], N );\n\tsx = resolveStride( lens[ 1 ], N );\n\tsy = resolveStride( lens[ 2 ], N );\n\n\t// Resolve accessors for retrieving array elements:\n\tcget = resolveGetter( condition );\n\txget = resolveGetter( x );\n\tyget = resolveGetter( y );\n\n\t// Initialize indices:\n\tic = 0;\n\tix = 0;\n\tiy = 0;\n\n\t// Extract each desired element from a provided array...\n\tout = [];\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( cget( condition, ic ) ) {\n\t\t\tv = xget( x, ix );\n\t\t} else {\n\t\t\tv = yget( y, iy );\n\t\t}\n\t\tout.push( v ); // use `Array#push` to ensure \"fast\" elements\n\t\tic += sc;\n\t\tix += sx;\n\t\tiy += sy;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = where;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar ceil = require( '@stdlib/math-base-special-ceil' );\n\n\n// MAIN //\n\n/**\n* Computes the number of indexed elements in a strided array.\n*\n* @private\n* @param {NonNegativeInteger} len - array length\n* @param {integer} stride - array stride\n* @param {NonNegativeInteger} offset - array offset\n* @returns {NonNegativeInteger} number of indexed elements\n*\n* @example\n* var N = numel( 10, -2, 9 );\n* // returns 5\n*\n* N = numel( 10, -2, 8 );\n* // returns 5\n*\n* N = numel( 10, -2, 7 );\n* // returns 4\n*\n* N = numel( 10, -2, 6 );\n* // returns 4\n*\n* N = numel( 10, -2, 5 );\n* // returns 3\n*\n* @example\n* var N = numel( 10, -3, 9 );\n* // returns 4\n*\n* N = numel( 10, -3, 8 );\n* // returns 3\n*\n* N = numel( 10, -3, 7 );\n* // returns 3\n*\n* N = numel( 10, -3, 6 );\n* // returns 3\n*\n* N = numel( 10, -3, 5 );\n* // returns 2\n*\n* @example\n* var N = numel( 10, 2, 0 );\n* // returns 5\n*\n* N = numel( 10, 2, 1 );\n* // returns 5\n*\n* N = numel( 10, 2, 2 );\n* // returns 4\n*\n* N = numel( 10, 2, 3 );\n* // returns 4\n*\n* @example\n* var N = numel( 10, 3, 0 );\n* // returns 4\n*\n* N = numel( 10, 3, 1 );\n* // returns 3\n*\n* N = numel( 10, 3, 2 );\n* // returns 3\n*\n* N = numel( 10, 3, 3 );\n* // returns 3\n*/\nfunction numel( len, stride, offset ) {\n\tif ( stride < 0 ) {\n\t\treturn ceil( (offset+1) / -stride );\n\t}\n\treturn ceil( (len-offset) / stride );\n}\n\n\n// EXPORTS //\n\nmodule.exports = numel;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isComplexDataType = require( '@stdlib/array-base-assert-is-complex-floating-point-data-type' );\nvar isBooleanDataType = require( '@stdlib/array-base-assert-is-boolean-data-type' );\nvar arraylike2object = require( '@stdlib/array-base-arraylike2object' );\nvar reinterpretCmplx = require( '@stdlib/strided-base-reinterpret-complex' );\nvar reinterpretBool = require( '@stdlib/strided-base-reinterpret-boolean' );\nvar resolveStride = require( './resolve_stride.js' );\nvar numel = require( './numel.js' );\n\n\n// FUNCTIONS //\n\n/**\n* Takes elements from either one indexed array or another depending on a condition and assigns the values to elements in an indexed output array.\n*\n* @private\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Collection} condition - indicator array\n* @param {Collection} x - first input array\n* @param {Collection} y - second input array\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @throws {Error} input arrays must be broadcast compatible with the output array\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var y = [ 5, 6, 7, 8 ];\n*\n* var out = [ 0, 0, 0, 0 ];\n* var condition = [ true, false, true, false ];\n*\n* var arr = indexed( out.length, condition, x, y, out, 1, 0 );\n* // returns [ 1, 6, 3, 8 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\nfunction indexed( N, condition, x, y, out, stride, offset ) {\n\tvar sx;\n\tvar sy;\n\tvar sc;\n\tvar ix;\n\tvar iy;\n\tvar ic;\n\tvar io;\n\tvar i;\n\n\t// Broadcast the arrays by computing strides:\n\tsc = resolveStride( condition.length, N );\n\tsx = resolveStride( x.length, N );\n\tsy = resolveStride( y.length, N );\n\n\t// Initialize indices:\n\tic = 0;\n\tix = 0;\n\tiy = 0;\n\tio = offset;\n\n\t// Extract each desired element from a provided array...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout[ io ] = ( condition[ ic ] ) ? x[ ix ] : y[ iy ];\n\t\tic += sc;\n\t\tix += sx;\n\t\tiy += sy;\n\t\tio += stride;\n\t}\n\treturn out;\n}\n\n/**\n* Takes elements from either one accessor array or another depending on a condition and assigns the values to elements in an accessor output array.\n*\n* @private\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Object} condition - condition array object\n* @param {Object} x - first input array object\n* @param {Object} y - second input array object\n* @param {Object} out - output array object\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = toAccessorArray( [ 1, 2, 3, 4 ] );\n* var y = toAccessorArray( [ 5, 6, 7, 8 ] );\n*\n* var condition = toAccessorArray( [ true, false, true, false ] );\n*\n* var out = toAccessorArray( [ 0, 0, 0, 0 ] );\n* var arr = accessors( out.length, arraylike2object( condition ), arraylike2object( x ), arraylike2object( y ), arraylike2object( out ), 1, 0 );\n*\n* var v = arr.get( 0 );\n* // returns 1\n*\n* v = arr.get( 1 );\n* // returns 6\n*/\nfunction accessors( N, condition, x, y, out, stride, offset ) {\n\tvar xdata;\n\tvar ydata;\n\tvar cdata;\n\tvar odata;\n\tvar xget;\n\tvar yget;\n\tvar cget;\n\tvar oset;\n\tvar sx;\n\tvar sy;\n\tvar sc;\n\tvar ix;\n\tvar iy;\n\tvar ic;\n\tvar io;\n\tvar i;\n\n\tcdata = condition.data;\n\txdata = x.data;\n\tydata = y.data;\n\todata = out.data;\n\n\tcget = condition.accessors[ 0 ];\n\txget = x.accessors[ 0 ];\n\tyget = y.accessors[ 0 ];\n\toset = out.accessors[ 1 ];\n\n\t// Broadcast the arrays by computing strides:\n\tsc = resolveStride( cdata.length, N );\n\tsx = resolveStride( xdata.length, N );\n\tsy = resolveStride( ydata.length, N );\n\n\t// Initialize indices:\n\tic = 0;\n\tix = 0;\n\tiy = 0;\n\tio = offset;\n\n\t// Extract each desired element from a provided array...\n\tfor ( i = 0; i < N; i++ ) {\n\t\toset( odata, io, ( cget( cdata, ic ) ) ? xget( xdata, ix ) : yget( ydata, iy ) ); // eslint-disable-line max-len\n\t\tic += sc;\n\t\tix += sx;\n\t\tiy += sy;\n\t\tio += stride;\n\t}\n\treturn odata;\n}\n\n/**\n* Takes elements from either one complex array or another depending on a condition and assigns the values to elements in a complex output array.\n*\n* @private\n* @param {NonNegativeInteger} N - number of indexed elements\n* @param {Object} condition - condition array object\n* @param {Collection} x - first real-valued floating-point input array view\n* @param {Collection} y - second real-valued floating-point input array view\n* @param {Collection} out - real-valued floating-point output array view\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array view\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var y = new Float64Array( [ 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0 ] );\n*\n* var condition = [ true, false, true, false ];\n*\n* var out = new Float64Array( 8 );\n*\n* var arr = complex( 4, arraylike2object( condition ), x, y, out, 1, 0 );\n* // returns <Float64Array>[ 1.0, 2.0, 11.0, 12.0, 5.0, 6.0, 15.0, 16.0 ]\n*/\nfunction complex( N, condition, x, y, out, stride, offset ) {\n\tvar cdata;\n\tvar cget;\n\tvar sx;\n\tvar sy;\n\tvar sc;\n\tvar so;\n\tvar ix;\n\tvar iy;\n\tvar ic;\n\tvar io;\n\tvar i;\n\n\tcdata = condition.data;\n\tcget = condition.accessors[ 0 ];\n\n\t// Broadcast the arrays by computing strides (note: multiply strides by 2 for complex array arguments, as a real-valued array view consists of interleaved real and imaginary components):\n\tsc = resolveStride( cdata.length, N );\n\tsx = resolveStride( x.length/2, N ) * 2;\n\tsy = resolveStride( y.length/2, N ) * 2;\n\tso = stride * 2;\n\n\t// Initialize indices:\n\tic = 0;\n\tix = 0;\n\tiy = 0;\n\tio = offset * 2; // note: account for interleaved real and imaginary components\n\n\t// Extract each desired element from a provided array...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( cget( cdata, ic ) ) {\n\t\t\tout[ io ] = x[ ix ];\n\t\t\tout[ io+1 ] = x[ ix+1 ];\n\t\t} else {\n\t\t\tout[ io ] = y[ iy ];\n\t\t\tout[ io+1 ] = y[ iy+1 ];\n\t\t}\n\t\tic += sc;\n\t\tix += sx;\n\t\tiy += sy;\n\t\tio += so;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Takes elements from either one of two arrays depending on a condition and assigns the values to elements in a provided output array.\n*\n* @param {Collection} condition - indicator array\n* @param {Collection} x - first input array\n* @param {Collection} y - second input array\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @throws {Error} input arrays must be broadcast compatible with the output array\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var y = [ 5, 6, 7, 8 ];\n*\n* var out = [ 0, 0, 0, 0 ];\n* var condition = [ true, false, true, false ];\n*\n* var arr = assign( condition, x, y, out, 1, 0 );\n* // returns [ 1, 6, 3, 8 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\nfunction assign( condition, x, y, out, stride, offset ) {\n\tvar co;\n\tvar xo;\n\tvar yo;\n\tvar oo;\n\tvar N;\n\n\t// Check whether we can avoid doing any work...\n\tif ( condition.length === 0 ) {\n\t\treturn out;\n\t}\n\t// Compute the number of indexed elements in the output array:\n\tN = numel( out.length, stride, offset );\n\n\tco = arraylike2object( condition );\n\tif ( isBooleanDataType( co.dtype ) ) {\n\t\tco = arraylike2object( reinterpretBool( condition, 0 ) );\n\t}\n\txo = arraylike2object( x );\n\tyo = arraylike2object( y );\n\too = arraylike2object( out );\n\tif (\n\t\tco.accessorProtocol ||\n\t\txo.accessorProtocol ||\n\t\tyo.accessorProtocol ||\n\t\too.accessorProtocol\n\t) {\n\t\t// Note: we only explicitly special case a select number of same dtype-to-dtype combinations, as this function should not be concerned with casting rules, etc. That is left to userland...\n\t\tif (\n\t\t\tco.accessorProtocol === false &&\n\t\t\tisBooleanDataType( xo.dtype ) &&\n\t\t\tisBooleanDataType( yo.dtype ) &&\n\t\t\tisBooleanDataType( oo.dtype )\n\t\t) {\n\t\t\tindexed( N, co.data, reinterpretBool( x, 0 ), reinterpretBool( y, 0 ), reinterpretBool( out, 0 ), stride, offset ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\tif (\n\t\t\tisComplexDataType( xo.dtype ) &&\n\t\t\tisComplexDataType( yo.dtype ) &&\n\t\t\tisComplexDataType( oo.dtype )\n\t\t) {\n\t\t\tcomplex( N, co, reinterpretCmplx( x, 0 ), reinterpretCmplx( y, 0 ), reinterpretCmplx( out, 0 ), stride, offset ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\taccessors( N, co, xo, yo, oo, stride, offset );\n\t\treturn out;\n\t}\n\tindexed( N, condition, x, y, out, stride, offset );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = assign;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Take elements from either one of two arrays depending on a condition.\n*\n* @module @stdlib/array-base-where\n*\n* @example\n* var where = require( '@stdlib/array-base-where' );\n*\n* var x = [ 1, 2, 3, 4 ];\n* var y = [ 5, 6, 7, 8 ];\n*\n* var condition = [ true, false, true, false ];\n*\n* var z = where( condition, x, y );\n* // returns [ 1, 6, 3, 8 ]\n*\n* @example\n* var where = require( '@stdlib/array-base-where' );\n*\n* var x = [ 1, 2, 3, 4 ];\n* var y = [ 5, 6, 7, 8 ];\n*\n* var out = [ 0, 0, 0, 0 ];\n* var condition = [ true, false, true, false ];\n*\n* var arr = where.assign( condition, x, y, out, 1, 0 );\n* // returns [ 1, 6, 3, 8 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,GAAAC,EAAA,cA+BA,SAASC,EAAeC,EAAGC,EAAI,CAE9B,GAAKD,IAAM,EACV,MAAO,GAER,GAAKA,IAAMC,EACV,MAAO,GAER,MAAM,IAAI,MAAO,kEAAmE,CACrF,CAKAH,EAAO,QAAUC,IC7CjB,IAAAG,EAAAC,EAAA,SAAAC,GAAAC,EAAA,cAsBA,IAAIC,EAAgB,QAAS,mCAAoC,EAC7DC,EAAO,QAAS,gCAAiC,EACjDC,EAAgB,IAuBpB,SAASC,EAAOC,EAAWC,EAAGC,EAAI,CACjC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAMJ,GAHAV,EAAO,CAAEN,EAAU,OAAQC,EAAE,OAAQC,EAAE,MAAO,EAGzCI,EAAM,CAAE,IAAM,EAElB,MAAO,CAAC,EAsBT,IAnBAQ,EAAIjB,EAAMS,EAAM,CAAE,EAAGA,EAAM,CAAE,EAAGA,EAAM,CAAE,CAAE,EAG1CI,EAAKZ,EAAeQ,EAAM,CAAE,EAAGQ,CAAE,EACjCN,EAAKV,EAAeQ,EAAM,CAAE,EAAGQ,CAAE,EACjCL,EAAKX,EAAeQ,EAAM,CAAE,EAAGQ,CAAE,EAGjCT,EAAOT,EAAeI,CAAU,EAChCG,EAAOP,EAAeK,CAAE,EACxBG,EAAOR,EAAeM,CAAE,EAGxBW,EAAK,EACLF,EAAK,EACLC,EAAK,EAGLL,EAAM,CAAC,EACDS,EAAI,EAAGA,EAAIF,EAAGE,IACdX,EAAML,EAAWa,CAAG,EACxBE,EAAIZ,EAAMF,EAAGU,CAAG,EAEhBI,EAAIX,EAAMF,EAAGU,CAAG,EAEjBL,EAAI,KAAMQ,CAAE,EACZF,GAAMH,EACNC,GAAMH,EACNI,GAAMH,EAEP,OAAOF,CACR,CAKAZ,EAAO,QAAUI,IC5GjB,IAAAkB,EAAAC,EAAA,SAAAC,GAAAC,EAAA,cAsBA,IAAIC,EAAO,QAAS,gCAAiC,EAwErD,SAASC,EAAOC,EAAKC,EAAQC,EAAS,CACrC,OAAKD,EAAS,EACNH,GAAOI,EAAO,GAAK,CAACD,CAAO,EAE5BH,GAAOE,EAAIE,GAAUD,CAAO,CACpC,CAKAJ,EAAO,QAAUE,ICxGjB,IAAAI,EAAAC,EAAA,SAAAC,GAAAC,EAAA,cAsBA,IAAIC,EAAoB,QAAS,+DAAgE,EAC7FC,EAAoB,QAAS,gDAAiD,EAC9EC,EAAmB,QAAS,qCAAsC,EAClEC,EAAmB,QAAS,0CAA2C,EACvEC,EAAkB,QAAS,0CAA2C,EACtEC,EAAgB,IAChBC,EAAQ,IAgCZ,SAASC,EAASC,EAAGC,EAAWC,EAAGC,EAAGC,EAAKC,EAAQC,EAAS,CAC3D,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAcJ,IAXAL,EAAKZ,EAAeI,EAAU,OAAQD,CAAE,EACxCO,EAAKV,EAAeK,EAAE,OAAQF,CAAE,EAChCQ,EAAKX,EAAeM,EAAE,OAAQH,CAAE,EAGhCY,EAAK,EACLF,EAAK,EACLC,EAAK,EACLE,EAAKP,EAGCQ,EAAI,EAAGA,EAAId,EAAGc,IACnBV,EAAKS,CAAG,EAAMZ,EAAWW,CAAG,EAAMV,EAAGQ,CAAG,EAAIP,EAAGQ,CAAG,EAClDC,GAAMH,EACNC,GAAMH,EACNI,GAAMH,EACNK,GAAMR,EAEP,OAAOD,CACR,CAiCA,SAASW,EAAWf,EAAGC,EAAWC,EAAGC,EAAGC,EAAKC,EAAQC,EAAS,CAC7D,IAAIU,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAhB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAwBJ,IAtBAI,EAAQjB,EAAU,KAClBe,EAAQd,EAAE,KACVe,EAAQd,EAAE,KACVgB,EAAQf,EAAI,KAEZkB,EAAOrB,EAAU,UAAW,CAAE,EAC9BmB,EAAOlB,EAAE,UAAW,CAAE,EACtBmB,EAAOlB,EAAE,UAAW,CAAE,EACtBoB,EAAOnB,EAAI,UAAW,CAAE,EAGxBK,EAAKZ,EAAeqB,EAAM,OAAQlB,CAAE,EACpCO,EAAKV,EAAemB,EAAM,OAAQhB,CAAE,EACpCQ,EAAKX,EAAeoB,EAAM,OAAQjB,CAAE,EAGpCY,EAAK,EACLF,EAAK,EACLC,EAAK,EACLE,EAAKP,EAGCQ,EAAI,EAAGA,EAAId,EAAGc,IACnBS,EAAMJ,EAAON,EAAMS,EAAMJ,EAAON,CAAG,EAAMQ,EAAMJ,EAAON,CAAG,EAAIW,EAAMJ,EAAON,CAAG,CAAE,EAC/EC,GAAMH,EACNC,GAAMH,EACNI,GAAMH,EACNK,GAAMR,EAEP,OAAOc,CACR,CA6BA,SAASK,EAASxB,EAAGC,EAAWC,EAAGC,EAAGC,EAAKC,EAAQC,EAAS,CAC3D,IAAIY,EACAI,EACAf,EACAC,EACAC,EACAgB,EACAf,EACAC,EACAC,EACAC,EACAC,EAkBJ,IAhBAI,EAAQjB,EAAU,KAClBqB,EAAOrB,EAAU,UAAW,CAAE,EAG9BQ,EAAKZ,EAAeqB,EAAM,OAAQlB,CAAE,EACpCO,EAAKV,EAAeK,EAAE,OAAO,EAAGF,CAAE,EAAI,EACtCQ,EAAKX,EAAeM,EAAE,OAAO,EAAGH,CAAE,EAAI,EACtCyB,EAAKpB,EAAS,EAGdO,EAAK,EACLF,EAAK,EACLC,EAAK,EACLE,EAAKP,EAAS,EAGRQ,EAAI,EAAGA,EAAId,EAAGc,IACdQ,EAAMJ,EAAON,CAAG,GACpBR,EAAKS,CAAG,EAAIX,EAAGQ,CAAG,EAClBN,EAAKS,EAAG,CAAE,EAAIX,EAAGQ,EAAG,CAAE,IAEtBN,EAAKS,CAAG,EAAIV,EAAGQ,CAAG,EAClBP,EAAKS,EAAG,CAAE,EAAIV,EAAGQ,EAAG,CAAE,GAEvBC,GAAMH,EACNC,GAAMH,EACNI,GAAMH,EACNK,GAAMY,EAEP,OAAOrB,CACR,CA8BA,SAASsB,EAAQzB,EAAWC,EAAGC,EAAGC,EAAKC,EAAQC,EAAS,CACvD,IAAIqB,EACAC,EACAC,EACAC,EACA9B,EAGJ,OAAKC,EAAU,SAAW,EAClBG,GAGRJ,EAAIF,EAAOM,EAAI,OAAQC,EAAQC,CAAO,EAEtCqB,EAAKjC,EAAkBO,CAAU,EAC5BR,EAAmBkC,EAAG,KAAM,IAChCA,EAAKjC,EAAkBE,EAAiBK,EAAW,CAAE,CAAE,GAExD2B,EAAKlC,EAAkBQ,CAAE,EACzB2B,EAAKnC,EAAkBS,CAAE,EACzB2B,EAAKpC,EAAkBU,CAAI,EAE1BuB,EAAG,kBACHC,EAAG,kBACHC,EAAG,kBACHC,EAAG,iBAIFH,EAAG,mBAAqB,IACxBlC,EAAmBmC,EAAG,KAAM,GAC5BnC,EAAmBoC,EAAG,KAAM,GAC5BpC,EAAmBqC,EAAG,KAAM,GAE5B/B,EAASC,EAAG2B,EAAG,KAAM/B,EAAiBM,EAAG,CAAE,EAAGN,EAAiBO,EAAG,CAAE,EAAGP,EAAiBQ,EAAK,CAAE,EAAGC,EAAQC,CAAO,EAC1GF,GAGPZ,EAAmBoC,EAAG,KAAM,GAC5BpC,EAAmBqC,EAAG,KAAM,GAC5BrC,EAAmBsC,EAAG,KAAM,GAE5BN,EAASxB,EAAG2B,EAAIhC,EAAkBO,EAAG,CAAE,EAAGP,EAAkBQ,EAAG,CAAE,EAAGR,EAAkBS,EAAK,CAAE,EAAGC,EAAQC,CAAO,EACxGF,IAERW,EAAWf,EAAG2B,EAAIC,EAAIC,EAAIC,EAAIzB,EAAQC,CAAO,EACtCF,IAERL,EAASC,EAAGC,EAAWC,EAAGC,EAAGC,EAAKC,EAAQC,CAAO,EAC1CF,GACR,CAKAb,EAAO,QAAUmC,IClRjB,IAAIK,EAAc,QAAS,uDAAwD,EAC/EC,EAAO,IACPC,EAAS,IAKbF,EAAaC,EAAM,SAAUC,CAAO,EAKpC,OAAO,QAAUD",
  "names": ["require_resolve_stride", "__commonJSMin", "exports", "module", "resolveStride", "M", "N", "require_main", "__commonJSMin", "exports", "module", "resolveGetter", "maxn", "resolveStride", "where", "condition", "x", "y", "xget", "yget", "cget", "lens", "out", "sx", "sy", "sc", "ix", "iy", "ic", "N", "v", "i", "require_numel", "__commonJSMin", "exports", "module", "ceil", "numel", "len", "stride", "offset", "require_assign", "__commonJSMin", "exports", "module", "isComplexDataType", "isBooleanDataType", "arraylike2object", "reinterpretCmplx", "reinterpretBool", "resolveStride", "numel", "indexed", "N", "condition", "x", "y", "out", "stride", "offset", "sx", "sy", "sc", "ix", "iy", "ic", "io", "i", "accessors", "xdata", "ydata", "cdata", "odata", "xget", "yget", "cget", "oset", "complex", "so", "assign", "co", "xo", "yo", "oo", "setReadOnly", "main", "assign"]
}
